<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Nanoborg Simulation</title>
<style>
  canvas {
    border: 1px solid blue;
    background: white;
  }
  #layout {
    display: flex;
    align-items: flex-start;
  }
  #controls {
    margin-top: 10px;
  }
  #stats {
    margin-left: 10px;
    font-family: sans-serif;
  }
</style>
</head>
<body>
<div id="layout">
  <canvas id="canvas" width="256" height="256"></canvas>
  <div id="stats">
    <div>Durchschnittlicher Score: <span id="avgScore">0</span></div>
    <div>High: <span id="highCount">0</span></div>
    <div>Low: <span id="lowCount">0</span></div>
  </div>
</div>
<div id="controls">
  <label>WÃ¼rmchen: <input type="range" id="wormCount" min="100" max="5000" value="3000"><span id="wormCountVal"></span></label>
  <label>Mutationsrate: <input type="range" id="mutationRate" min="0" max="0.01" step="0.0001" value="0.001"><span id="mutationRateVal"></span></label>
  <label>Transferanteil: <input type="range" id="transferFraction" min="0" max="1" step="0.01" value="0.1"><span id="transferFractionVal"></span></label>
  <label>Geschwindigkeit: <input type="range" id="simSpeed" min="1" max="5" step="1" value="1"><span id="simSpeedVal"></span></label>
  <button id="restart">Neu starten</button>
</div>
<script>
(function(){
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const SIZE = 256;

  const valueElems = {
    wormCount: document.getElementById('wormCountVal'),
    mutationRate: document.getElementById('mutationRateVal'),
    transferFraction: document.getElementById('transferFractionVal'),
    simSpeed: document.getElementById('simSpeedVal')
  };
  ['wormCount','mutationRate','transferFraction','simSpeed'].forEach(id=>{
    const input=document.getElementById(id);
    const span=valueElems[id];
    function update(){span.textContent=input.value;}
    input.addEventListener('input',update);
    update();
  });
  const DIRS = [
    [1,0],
    [0,1],
    [-1,0],
    [0,-1]
  ];
  let worms = [];
  let tailMap;
  let headMap;
  let stepCounter = 0;
  function randInt(max){return Math.floor(Math.random()*max);}
  function randFloat(min,max){return Math.random()*(max-min)+min;}
  function reset(){
    const count = parseInt(document.getElementById('wormCount').value,10);
    const mutation = parseFloat(document.getElementById('mutationRate').value);
    const transfer = parseFloat(document.getElementById('transferFraction').value);
    const speed = parseInt(document.getElementById('simSpeed').value,10);
    worms = [];
    for(let i=0;i<count;i++){
      worms.push(createWorm(i));
    }
    tailMap = new Map();
    window.simParams = {mutation,transfer,speed};
  }
  function createWorm(index){
    const w={};
    w.x=randInt(SIZE);
    w.y=randInt(SIZE);
    w.tailX=w.x;
    w.tailY=w.y;
    w.dir=randInt(4);
    w.data=new Float32Array(32);
    w.program=[];
    w.score=0.5;
    w.data[0]=1.0;
    w.data[1]=0.0;
    w.data[2]=-1.0;
    for(let i=9;i<=29;i++) w.data[i]=randFloat(-1,1);
    for(let i=0;i<32;i++){
      w.program.push({
        alpha:Math.random(),
        src1:randInt(30),
        src2:randInt(30),
        dst:9+randInt(23)
      });
    }
    return w;
  }
  function sense(w){
    const fDir=DIRS[w.dir];
    const rDir=DIRS[(w.dir+1)%4];
    const lDir=DIRS[(w.dir+3)%4];
    const fx=w.x+fDir[0], fy=w.y+fDir[1];
    const rx=w.x+rDir[0], ry=w.y+rDir[1];
    const lx=w.x+lDir[0], ly=w.y+lDir[1];
    const fKey=`${fx},${fy}`;
    const rKey=`${rx},${ry}`;
    const lKey=`${lx},${ly}`;
    w.data[6]=(fx<0||fx>=SIZE||fy<0||fy>=SIZE)?1:0;
    w.data[7]=(rx<0||rx>=SIZE||ry<0||ry>=SIZE)?1:0;
    w.data[8]=(lx<0||lx>=SIZE||ly<0||ly>=SIZE)?1:0;
    function senseCell(key, selfIdx){
      let val = 0;
      const hId = headMap.get(key);
      if(hId !== undefined && hId !== selfIdx) val = -1;
      const tId = tailMap.get(key);
      if(tId !== undefined && tId !== selfIdx && val === 0) val = 1;
      return val;
    }
    w.data[3]=senseCell(fKey, w.index);
    w.data[4]=senseCell(rKey, w.index);
    w.data[5]=senseCell(lKey, w.index);
  }
  function executeProgram(w){
    const d=w.data;
    for(const ins of w.program){
      d[ins.dst]+=ins.alpha*(d[ins.src1]*d[ins.src2]-d[ins.dst]);
    }
  }
  function move(w){
    if(w.data[31]>0) w.dir=(w.dir+1)%4;
    else if(w.data[31]<0) w.dir=(w.dir+3)%4;
    let nx=w.x,ny=w.y;
    if(w.data[30]>0){
      nx+=DIRS[w.dir][0];
      ny+=DIRS[w.dir][1];
    }
    if(nx<0||nx>=SIZE||ny<0||ny>=SIZE){
      nx=w.x;ny=w.y;
    }
    const key=`${nx},${ny}`;
    const coll=tailMap.get(key);
    if(coll!==undefined&&coll!==w.index){
      const other=worms[coll];
      w.score=Math.min(1,w.score+0.02);
      other.score=Math.max(0,other.score-0.02);
      if(w.score>0.9&&other.score<0.1) transferProgram(w,other);
      else if(w.score<0.1&&other.score>0.9) transferProgram(other,w);
    }
    w.tailX=w.x;w.tailY=w.y;
    w.x=nx;w.y=ny;
  }
  function transferProgram(from,to){
    const fraction=window.simParams.transfer;
    const countProg=Math.floor(from.program.length*fraction);
    for(let i=0;i<countProg;i++){
      const idx=randInt(from.program.length);
      to.program[idx]=Object.assign({},from.program[idx]);
      if(Math.random()<window.simParams.mutation){
        to.program[idx]={alpha:Math.random(),src1:randInt(30),src2:randInt(30),dst:9+randInt(23)};
      }
    }
    const countData=Math.floor((32-2)*fraction);
    for(let i=0;i<countData;i++){
      const idx=2+randInt(30);
      to.data[idx]=from.data[idx];
      if(Math.random()<window.simParams.mutation && idx>=9 && idx<=29){
        to.data[idx]=randFloat(-1,1);
      }
    }
    to.x=randInt(SIZE);to.y=randInt(SIZE);to.tailX=to.x;to.tailY=to.y;
  }
  function draw(){
    ctx.clearRect(0,0,SIZE,SIZE);
    for(const w of worms){
      const color=w.score>0.9?'red':'green';
      ctx.fillStyle=color;
      if(w.dir%2===0){ // horizontal
        ctx.fillRect(w.tailX, w.tailY,2,1);
        ctx.fillStyle=w.score>0.9?'red':'turquoise';
        ctx.fillRect(w.x, w.y,1,1);
      }else{ // vertical
        ctx.fillRect(w.tailX, w.tailY,1,2);
        ctx.fillStyle=w.score>0.9?'red':'turquoise';
        ctx.fillRect(w.x, w.y,1,1);
      }
    }
  }
  function updateStats(){
    let high=0,low=0,total=0;
    for(const w of worms){
      total+=w.score;
      if(w.score>0.9) high++;
      if(w.score<0.1) low++;
    }
    document.getElementById('avgScore').textContent=(total/worms.length).toFixed(3);
    document.getElementById('highCount').textContent=high;
    document.getElementById('lowCount').textContent=low;
  }
  function stepOnce(){
    tailMap=new Map();
    headMap=new Map();
    worms.forEach((w,i)=>{
      w.index=i;
      tailMap.set(`${w.tailX},${w.tailY}`,i);
      headMap.set(`${w.x},${w.y}`,i);
    });
    for(const w of worms){
      sense(w);
    }
    for(const w of worms){
      executeProgram(w);
      move(w);
    }
    draw();
    stepCounter++;
    updateStats();
  }
  function step(){
    for(let i=0;i<window.simParams.speed;i++){
      stepOnce();
    }
    requestAnimationFrame(step);
  }
  document.getElementById('restart').addEventListener('click',reset);
  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
